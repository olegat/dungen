\chapter{Random Number Generation}
It is obvious that the aspect of randomness is a crucial factor in procedural content generation. Random numbers are required for countless reasons. They can be used to pick a random element in a set or to assign a random value to a variable. Generating random numbers is a concept that has been in the field of research for many years and, although solutions exist, it remains a delicate task. 

In most cases a pseudo-random number generator (PRNG) can be used to generate numbers, although these do not provide a true random result. The term ``pseudo-random" is used to define a sequence of deterministic generated numbers with a distribution that closely resembles that of random variable. Because of the fact that random numbers generated by a PRNG are defined by a mathematical formula, poor PRNG algorithms suffer from several issues such as predictability and dependent distributions \citep{frieze_lcg}.

\section{Linear Congruential Generators}
Linear congruential generators (LCG), proposed several decades ago by D. H. Lehmer, are amongst the oldest and most common PRNG \citep{park_miller}. Requiring nothing but a single variable and a simple formula for generating numbers, they are considered very memory and time-efficient. Their space and time complexity are of order $\bigo{1}$ \citep{Knuth_art2}.

As direct result of their simplicity and efficiency, LCGs are often used in certain applications such as simulations where a satisfactory result that ``looks good" is required. However they present the disadvantage of producing predictable and dependent variables \citep{frieze_lcg}.

\subsection{Recurrence relation}
Linear congruential generators are mathematically described by the following recurrence relation:

\[ X_{n+1} = (a X_{n} + c) \modulo M \]

This recursive formula is used to generate a sequence of numbers $\{X_0, X_1, X_2,...\}$ with a seemingly random uniform distribution \citep{Knuth_art2} where each variable represents the following (as explained by \citep{hamid_lcgSecurity}):
\begin{itemize}
\item $X_{n+1}$ is the next ``random" number in the sequence $\{X_0, X_1, X_2,...\}$. It is referred to as \texttt{next()} in some implementations such as .NET's \texttt{System.Random} class \citep{System.Random} or Java's \texttt{java.util.Random} class \citep{java.util.Random}.
\item $M$ is called the {\em modulus}, generally a large prime number \citep{park_miller}
\item $a$ is called the {\em multiplier}. $0<a<M$
\item $c$ is called the {\em increment}. $0 \leq c<M$
\item The operation $ \modulo $ is called the modulo and defines the remainder of an integer-division.
\end{itemize}

\subsubsection{Seed}
As with all recurrence relations, the formula requires a starting point. In other words the formula should be defined as the following:

\begin{align}
 X_{0} &= k \nonumber \\
 X_{n+1} &= (a X_{n} + c) \modulo M \nonumber
\end{align} 

Where $k$ is a constant. The initial value $X_0$ is called the {\em seed} of the generator \citep{hamid_lcgSecurity}. In some implementations such as the  \texttt{java.util.Random} class the variable $X_n$ is also called the seed \citep{java.util.Random}, although generally speaking the term {\em seed} refers to $X_0$. 

It is trivial yet important to note that LCGs are ironically deterministic. Two identical LCGs (meaning the values for $a$, $c$ and $M$ are the same) will give exactly the same sequence of numbers if the seed is the same for both LCGs. This is a key concept in PRNG algorithms. Any program that utilises a pseudo-random number generator will provide exactly the same result if all given inputs (including the seed) are the same \citep{Knuth_art2}.

This is an obvious problem since the aim of any PRNG is to mimic the aspect of non-determinism. In order to obtain a different result we require a different seed. Typically, whenever a random seed is needed the computer's time can be used as the seed because this is guaranteed to be unique. The clock time is a feature related to time, which breaks the determinism of the LCG and provides a more unpredictable result \citep{Knuth_art2}.

\subsubsection{Period}
Another problem with LCGs is that the sequence produced is essentially always the same even when using a different seed. This issue is easiest to explain with the use of an example. 

\begin{itemize}
\item Let us consider two generators $L_X$ and $L_Y$ that differ only by their seeds.
\item Let $X_0$ and $Y_0$ be the seeds of $L_X$ and $L_Y$ respectively.
\item Let $a = 3,\;c = 1,\;M = 7$. These values for $a$, $c$ and $M$ are most certainly non-ideal but are used only for the purpose of demonstration.
\end{itemize}

We can calculate the numbers generated by the first LCG $L_X$ when its seed is $X_0 = 1$ for instance:

$$ \{X_0, X_1, X_2, ...\} = \{1,\,4,\,6,\,5,\,2,\,0,\,1,\,4,\,6,\,5,\,2,\,0,\,1,\,4,\,...\} $$ 

We can do the same for the second LCG $L_Y$ with a different seed $Y_0 = 5$:

$$ \{Y_0, Y_1, Y_2, ...\} = \{5,\,2,\,0,\,1,\,4,\,6,\,5,\,2,\,0,\,1,\,4,\,6,\,5,\,2,\,...\} $$ 

Here we notice two things:
\begin{itemize}
\item The infinite sequence produced by $L_Y$ is nothing more than the sequence from $L_X$ with an offset. In mathematically terms: 
\\ $ \{X_0, X_1, X_2, ...\} = \{Y_3, Y_4, Y_5, ...\} $
\item The infinite sequence produced by both $L_X$ and $L_Y$ is simply an infinite repetition of a finite sequence
\end{itemize}
Both of these observations are due to the mathematical determinism of the method. In other words, given a certain input to the LCG, say $X=1$, the result will always be 4.

\subsection{Advantages and Disadvantages}
\paragraph{Advantage} LCGs are famous for their efficiency and simplicity. They are easy to understand and implement. Requiring nothing more than a few simple operations such as bit-shifts and additions, they are computationally cheap \citep{wang_review} and only require a single 16-bit word of storage at-least \citep{yu_random}. Pierre L'Ecuyer has shown that larger word sizes can be used to provide more decent results \citep{lecuyer_tables}. Regardless of word-size used a single word is negligible on modern machines.

\paragraph{Disadvantages} 
As demonstrated by Pierre L'Ecuyer, LCGs can give satisfying results in certain applications such as simulations \citep{lecuyer_lcg_k1}. However, the quality of the pseudo-random numbers is very sensitive to the values assigned to its parameters $a$, $c$ and $M$. Bad choices for these parameters have historically lead to LCGs with inadequate results \citep{li_ooRandom}. Finding good coefficients for a LCG is very difficult and has been in the field of research for many years \citep{park_miller}. Generally in most applications, a known and reputable LCG will be used instead of innovating a new one. For instance, the LCG used in Java's \texttt{java.util.Random} class is based on the algorithm discussed by Donald E. Knuth in the {\em The Art of Programming: Volume 2} \citep{Knuth_art2}.

Aside from the concern for the quality of the result, LCGs also has a major concern regarding security. LCGs are notorious for their predictability even if the coefficients provide decent results \citep{hamid_lcgSecurity}. Plumstead has shown that the multiplier $a$ and multiplier $M$ can be inferred when a certain number of pseudo-random bits are revealed \citep{plumstead_predicting}. Therefore, using merely a fragment of a LCG's output, it is possible to predict the sequence of pseudo-random bits without knowing the coefficients $a$ and $M$ \citep{frieze_lcg}. Even worse, once the modulus becomes known we can predict the output with almost perfect certainty as demonstrated by Jacques Stern \citep{Stern_lcgInsecure}. Needless to say, this is a big concern for security because a high degree of unpredictability is required. Therefore LCGs are un-recommended for the use of cryptography. Some suitable alternatives derived from LCGs can be used for cryptography. An example is the Blum Blum Shub algorithm \citep{BlumBlumShub-1}.

\subsection{Constraints for good LCGs}
The aim of a number generator is to provide a sequence of numbers with good statistical properties and randomness \citep{hamid_lcgSecurity}. Naturally good randomness is required for simulation, but it has been shown by \citep{Knuth_decipher} and \citep{plumstead_predicting} that a LCG is more difficult to decipher if its output possesses good statistical randomness. This  makes statistical randomness the key element when designing a number generator.

Another essential feature for LCGs is the concept of full-period. A full period means that all values $0\leq X<M$ are generated once before the LCG returns to its initial state (i.e. it re-generates the initial seed) \citep{Knuth_art2}. Our previous example with the coefficients $a = 3$, $c = 1$, $M = 7$, $X_0=1$ is not a full-period LCG because the period generated does not include $3$:
\[\{1,\,4,\,6,\,5,\,2,\,0,\,1,...\}\]
A full-period LCG with a modulus $M=7$ would generate a period that includes all the numbers $\{0,\,1,\,...,\,6\}$. Donald Knuth has stated that a LCG has a full-period if and only if \citep{Knuth_art2}:
\begin{itemize}
\item The coefficients $c$ and $M$ are {\em relatively prime}, meaning they have no common dividers other than 1.
\item $a-1$ is divisible by all the prime factors of $M$.
\item If $M$ is a multiple of 4 then $a-1$ is so too.
\end{itemize}
However, full-period LCGs are not guaranteed to provide good results. In an example shown by Park and Miller they demonstrated this by using two similar number generators, both provided full-period sequences. These generators were given by formulas \((6 X \modulo 13)\) and \((7 X \modulo 13)\). However the former provided better statistical randomness, making it superior to the latter \citep{park_miller}.


\subsection{Examples of good and bad LCG}
Park and Miller suggested a good example of a LCG that provides adequate results. They refer to this LCG as the {\em minimal standard generator} \citep{park_miller}. This LCG uses the coefficients $M = 2^{31}-1$, $a = 7^5$ and $c = 0$. They claim that this LCG possesses both the full-period and statistical randomness properties. Additionally they also state that this LCG is easy to implement on nearly every computer system \citep{park_miller}.

\begin{quotation}
``We present the rationale for our choice of a minimal standard generator. We believe that this is the generator that should always be used -- unless one has access to a random number generator known to be better." \citep{park_miller}
\end{quotation}

Unfortunately good LCGs are difficult to find and hence there are many LCGs that suffer from certain defects \citep{park_miller}. Notably any number generator with a modulus of the form $M=2^n$ will suffer from an effect where lower bit are less significant and causes problems. For instance, the full-period mixed generator on UNIX platforms called \texttt{rand()} suffers from an issue where  the distribution of the lower bits is non-random \citep{park_miller}. The generator \texttt{rand()} used the parameters $a=1103515245$, c=$12345$ and $M=2^{31}$ \citep{park_miller}.

Another poor example of a LCG which suffers from the same effect that causes a defect in \texttt{rand()} is the random number generator in Turbo Pascal. The parameters used are $a=129$, $c=907633385$ and $M=2^{32}$, which is claimed to be even worse than the function \texttt{rand()} because the multiplier is simply too small \citep{park_miller}.

The worst example of any LCG must probably be the random generator known as RANDU. The coefficients are given by $a=2^{16}+ 3$, $c=0$ and $M=2^{31}$. These coefficients were chosen because they made the implementation of the algorithm very simple and it quickly became widespread \citep{park_miller}. However RANDU does not have a full period and the numbers generated have a distribution which is clearly non-random \citep{park_miller}.

\begin{quotation}
``...its very name RANDU is enough to bring dismay into the eyes and stomachs of many computer scientists!" \citep{Knuth_art2}
\end{quotation}

\section{Alternatives}
\subsection{Coupled Linear Congruential Generators}
In the attempt to make a PRNG that is efficient and cryptographically secure, Katti et al. suggested the use of Coupled Linear Congruential Generator (CLCG). This consists of using two LCGs with slightly different arguments to generate a sequence of bits. They show that breaking a CLCG is of complexity $\bigo{2^{2n}}$ where $n$ is the number of bits in the modulus $M$, which they consider as ``moderate security". However the authors confess that not all CLCGs pass the statistical tests of randomness, but they propose a modified version of CLCGs called dual-coupled LCG designed to provide statistically satisfying results. \citep{katti_coupledCG2}

\subsection{Mersenne twister}
Although LCGs generally provide adequate results they present major flaws in certain applications. One typical example is the Monte Carlo simulation that consists of repeatedly sampling data and testing them. Good statistical randomness is required in order for this simulation to work properly, LCGs simply don't have a level of randomness that is sufficient for a Monte Carlo simulation \citep{Itan-MonteCarlo}. In 1997, Makoto Matsumoto and Takuji Nishimura conceived a pseudo-random number generator known as the Mersenne twister. This method is optimised to provide statistical randomness and passes most statical tests \citep{DBLP:journals/tomacs/MatsumotoN98}. However this number generator on its own remains cryptographically insecure and shouldn't be used for this purpose, although it is possible to modify the algorithm to make it safe \citep{DBLP:journals/iacr/MatsumotoNHS05}.


\subsection{Blum Blum Shub}
PRNG algorithms such as LCG and Mersenne twister are fast and provide decent results. However, they are not cryptographically secure and are predictable. When considering randomness for security proposes, one must consider a different algorithm such as the {\em Blum Blum Shub} algorithm.

The name of the Blum Blum Shub algorithm is derived from its three creators Lenore Blum, Manuel Blum, and Michael Shub. \citep{BlumBlumShub-1} The formula used to generate pseudo-random bits is given as:

\[x_{n+1} = x^2_n \modulo M \]

Where $M$ is the product of two large prime numbers $p$ and $q$. The seed \(x_0 \notin \{0,1\} \) should be co-prime to $M = pq$ \citep{BlumBlumShub-2}.

This number generator is particularly useful in the field of cryptography because of its unpredictability. Predicting the output of the algorithm is possible, but it is a problem that is {\em computationally difficult} to solve. The problem is at-least as difficult as factorising $M$, which is an {\em NP-complete} problem \citep{BlumBlumShub-1}.

\pagebreak