\chapter{Conclusion}

Based on the research that was carried out is it clear now that procedural content generation (PCG) is a vast and very complicated field in computer science. We have observed a number of different techniques that can be used to generate content, each with their advantages and disadvantages. Amongst all these techniques are there is no single best PCG algorithm. Every content generator generally focuses on a particular type of environment and so a different technique should be used depending on the desired result. For example, using a search-based or rhythm-based method to generate mountains is probably not the best approach. Because of this, picking what kind of algorithm to use and how to implement it is very crucial.

To generate random content, one must have access to some sort of random elements. The randomness of the content is moderated through the use of random integers and floating-point numbers. Getting access to pure random numbers, meaning numbers that are truly random, is not really possible in computing. Instead, we use random number generators that create pseudo-random numbers. These numbers are entirely deterministic (apart from the time-based seed) but, if good parameters are used, they will have a distribution that appears to be random \citep{yu_random}.

Pseudo-random number generators including the Coupled Congruential Generator, the Mersenne Twister and the Blum Blum Shub are suitable in the field of cryptography. However cryptographically secure number generators are not required in simulations and therefore Linear Congruential Generators (LCG) are generally good enough for the use of procedural content generation. 

Finding and picking out a good LCG is an exceptionally difficult task to manoeuvre around. LCGs require a period that is as long as possible because those with a short period have historically caused a few issues. Large word-sizes for the modulo must be used along with other constraints in order to guarantee this long period. However a LCG with long period will not necessary provide good results. Statistical tests need to be performed on a LCG to insure that it produces numbers with adequate statistical randomness. Many different LCGs were examined in order to chose a satisfying number generator.

In addition to a good number generator, generating content requires the help of a solid and well-detailed mathematical model describing the patterns of the environment as closely as possible. These models vary tremendously for different types of environments and can be very difficult to conceptualise due to their complexity. For instance, to generate mountain-like environment Perlin noise can be used to generate a random height-map. Multiple random sine waves can also be used to generate a wavy height-map of a 2D game. Rhythm-based approaches can be used whenever timing is a crucial factor, such as 2D side-scroll platform games \citep{DBLP:journals/tciaig/SmithWMTMC11}. 

The model used to generate a dungeon-like environment is merely a tangent of maze generation. Mazes on their own already have a very elaborate theory established. Properties such as perfection, sparseness, biased and river are rigorously defined. There are multiple different algorithms that can be used to generate a perfect maze. Some of these algorithms are very similar to one another, such as the Depth-first search and Hunt-and-Kill algorithms, the Aldous-Broder and Wilson's algorithm, or the Binary-tree and Sidewinder. On the other hand some algorithms, such as the Recursive Division algorithm, are entirely different to all other algorithms. All these different algorithms have all been conceived in such a way that they all generate perfect mazes, however they all produce different types of mazes that can look very distinctive to one another.

Because of this wide variety of maze generators, picking which one to use is not obvious. The depth-first search and Hunt-and-Kill algorithm both have a large river factor which makes generally makes them produce more satisfying results \citep{JBuck}. However, algorithms like the Binary-tree algorithm are highly biased \citep{ThinkLabyrinth} which can potentially make them useful to one who wants to generate a dungeon that targets a specific direction.

Generating a basic mesh for the maze is not too complicated if we simply use 3D boxes to model the walls and tiled-textures for the UV mapping. From a programming perspective this is an efficient way to procedurally model the dungeon. But from an aesthetic point of view the result is not very satisfying. The aesthetic can be improved upon by using an occupancy-based algorithm; the method chosen consists of adding 3D meshes that are modelled by humans.

Despite the efforts, there is too much repetition and the dungeon looks similar almost everywhere. This is one of the major problems with PCG which was discussed very early on. PCG simply cannot produce levels that are unique. Even though levels are generated with different seeds and may look different they will still have obvious similarities. Some things can be done to reduce the repetition effect but it can never be blotted out completely. For instance, occupancy allows level designers to make specific parts of level look unique but chunks can still be re-used in several levels or within a level itself.

Overall we noticed that creating a generic framework for content generation is not simple because the possibilities are only limited to the imagination of designers. The algorithm used in the developed framework is essentially completely blank at the start and it is up to the user to define precisely how it should behave. There is an apparent reason for this: as specific details and constraints are added to desired result the generator's algorithm become increasingly more complex. In fact a slight change in the specification of the desired result can have a major impact on the algorithm used. Therefore resorting to a game-specific algorithm  might not always be a bad idea and this is probably why most game-developers focus on this.